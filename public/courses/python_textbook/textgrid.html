<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Работа с файлами аннотации TextGrid</title>
    <style>
        .chapter-content {
            font-family: Arial, sans-serif;
            line-height: 1.6;
        }

        h2 {
            color: #2c3e50;
        }

        .note {
            background: #f8f9fa;
            padding: 10px;
            border-left: 3px solid #3498db;
        }
    </style>
    <link href="styles/syntax_highlight.css" rel="stylesheet">
    <base target="_blank">
</head>

<body>
<div class="chapter-content">

<h3 id="файлы-аннотации-textgrid">Файлы аннотации TextGrid</h3>
<p>Программа Praat, широко использующаяся для фонетического анализа,
пользуется своим собственным форматом разметки, достаточно сильно
отличающимся от стандарта Wave Assistant. Этот формат называется
TextGrid. Чаще всего для хранения TextGrid используются текстовые файлы,
хотя Praat поддерживает и бинарные файлы; и у тех, и у других расширение
обычно .TextGrid. Важно заметить, что регистр обычно не важен на
системах Windows и Mac, но важен на Unix (в том числе в Google
Colab).</p>
<p>Praat не поддерживает использование произвольных кодировок в
текстовых файлах, доступные кодировки для чтения и записи указаны на
рисунках (обратите внимание, что кириллические кодировки не
поддерживаются).</p>
<img src="courses/python_textbook/images/praat_text_reading_settings.png" width="600">

<p></p>
<img src="courses/python_textbook/images/praat_text_writing_settings.png" width="600">

<p>Кроме этого, у Praat есть собственный стандарт для кодирования
специальных символов — т. н. триграфы (см. ниже).</p>
<p>Важным отличием формата TextGrid от стандарта Wave Assistant
заключается в том, что все временные значения в нём выражены в секундах
(и, соответственно, представляют собой вещественные числа).</p>
<p>Объект TextGrid представляет собой иерархическую структуру. Каждый
TextGrid имеет следующие параметры: время начала (<code>xmin</code>),
время конца (<code>xmax</code>) и количество уровней (<em>tiers</em>),
которые в него входят (<code>size</code>). Время начала и конца
определяют показываемую в Praat область сигнала: например, если сигнал
длиннее, чем время конца TextGrid, часть после времени конца
отображаться не будет. Время начала чаще всего равно 0, но может быть
любым положительным числом. Типичное начало файла TextGrid:</p>
<pre><code>File type = &quot;ooTextFile&quot;
Object class = &quot;TextGrid&quot;

xmin = 0 
xmax = 1.74762 
tiers? &lt;exists&gt; 
size = 5</code></pre>
<p>Каждый уровень также имеет время начала и конца (они могут отличаться
от родительских), а также имя (<code>name</code>). Имя может быть пустым
и не обязано быть уникальным, т. е. в одном объекте TextGrid могут быть
несколько уровней с одинаковым именем. Не рекомендуется использовать
нижнее подчёркивание <code>_</code> в названиях уровней, т. к. символы,
перед которыми идёт нижнее подчёркивание, в Praat отображаются как
подстрочные индексы (например, <code>"new_tier"</code> отобразится как
<em>new<sub>t</sub>ier</em>).</p>
<p>В Praat различаются два типа уровней: интервальные
(<em>IntervalTier</em>) и точечные (<em>PointTier</em>), их элементы
аннотации — интервалы (<em>Interval</em>) и точки (<em>Point</em>)
соответственно.</p>
<p>Интервалы имеют три поля: время начала и конца (<code>xmin</code> и
<code>xmax</code>) и текстовое поле (<code>text</code>). Фрагмент
TextGrid, содержащий начало интервального уровня:</p>
<pre><code>    item [1]:
        class = &quot;IntervalTier&quot; 
        name = &quot;phonetic real&quot; 
        xmin = 0 
        xmax = 1.747619047619047 
        intervals: size = 13 
        intervals [1]:
            xmin = 0 
            xmax = 0.192562358276644 
            text = &quot;j&quot; 
        intervals [2]:
            xmin = 0.192562358276644 
            xmax = 0.288163265306122 
            text = &quot;u0&quot;</code></pre>
<p>Точки имеют два поля: позиция (<code>number</code>) и текстовое поле
(<code>mark</code>).Фрагмент .TextGrid, содержащий начало точечного
уровня:</p>
<pre><code>    item [5]:
        class = &quot;TextTier&quot; 
        name = &quot;word boundaries&quot; 
        xmin = 0 
        xmax = 1.74762 
        points: size = 2 
        points [1]:
            number = 0.412244897959183 
            mark = &quot;1&quot; 
        points [2]:
            number = 1.239501133786848 
            mark = &quot;2&quot; </code></pre>
<p>Обратите внимание, что нумерация как уровней, так и элементов
аннотации в Praat начинается с единицы.</p>
<p>У текстовых файлов TextGrid есть т. н. «длинный» и «короткий»
варианты. Они содержат одну и ту же информацию, но в «коротких» файлах
не прописаны имена полей, что делает их менее подходящими для чтения
людьми. Фрагмент такого файла:</p>
<pre><code>File type = &quot;ooTextFile&quot;
Object class = &quot;TextGrid&quot;

0
1.74762
&lt;exists&gt;
5</code></pre>
<h3 id="библиотека-textgridtools">Библиотека TextGridTools</h3>
<p>Для работы с файлами TextGrid существует ряд библиотек. Одна из самых
популярных — TextGridTools. Её можно установить через командную строку с
помощью pip (чтобы сделать это в Google Colab, поставьте в начале строки
восклицательный знак <code>!</code>):</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cmd"><code class="sourceCode dosbat"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>pip install tgt</span></code></pre></div>
<p>По <a
href="https://textgridtools.readthedocs.io/en/stable/api.html">ссылке</a>
расположена документация, с которой стоит ознакомиться.</p>
<p>Прочитаем TextGrid с помощью функции <code>read_textgrid()</code>.
Эта функция принимает на вход три аргумента: имя файла, кодировку (по
умолчанию — utf-8) и логическое значение
<code>include_empty_intervals</code> (по умолчанию —
<code>False</code>), которое показывает, нужно ли сохранять интервалы с
пустым названием.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tgt</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> tgt.read_textgrid(<span class="st">&quot;cta0001.TextGrid&quot;</span>)</span></code></pre></div>
<p>Эта функция возвращает объект класса <code>TextGrid</code>, в котором
определён ряд полезных атрибутов и методов. В атрибуте
<code>tiers</code> хранится список всех уровней:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(grid.tiers)</span></code></pre></div>
<p>(вывод сокращён)</p>
<pre><code>[IntervalTier(start_time=0.0, end_time=1.747619047619047, name=&quot;phonetic real&quot;, ...), ...]</code></pre>
<p>Метод <code>.get_tier_names()</code> позволяет получить список имён
всех уровней:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(grid.get_tier_names())</span></code></pre></div>
<pre><code>[&#39;phonetic real&#39;, &#39;words&#39;, &#39;phonetic ideal&#39;, &#39;prosody&#39;, &#39;word boundaries&#39;]</code></pre>
<p>Метод <code>.get_tier_by_name()</code> позволяет получить уровень с
заданным названием (если их несколько, вернётся первый; если такого
уровня нет, будет вызвано исключение <code>ValueError</code>):</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(grid.get_tier_by_name(<span class="st">&quot;words&quot;</span>))</span></code></pre></div>
<p>(вывод сокращён)</p>
<pre><code>IntervalTier(start_time=0.0, end_time=1.747619047619047, name=&quot;words&quot;, ...)</code></pre>
<p>Чтобы получить список всех уровней с заданным названием, можно
использовать метод <code>.get_tiers_by_name()</code>. Чтобы определить,
есть ли уровень с заданным названием, используйте метод
<code>.has_tier()</code>.</p>
<p>В атрибутах <code>start_time</code> и <code>end_time</code> хранятся
время начала и конца соответственно.</p>
<p>Объект класса <code>TextGrid</code> — итерируемый объект, мы можем
получить все уровни простым циклом:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tier <span class="kw">in</span> grid:</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(tier)</span></code></pre></div>
<p>Каждый уровень (объект класса <code>IntervalTier</code> или
<code>PointTier</code>) также является итерируемым объектом:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>word_tier <span class="op">=</span> grid.get_tier_by_name(<span class="st">&quot;words&quot;</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> interval <span class="kw">in</span> word_tier:</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(interval)</span></code></pre></div>
<pre><code>Interval(0.0, 0.412244897959183, &quot;юрий&quot;)
Interval(0.412244897959183, 1.239501133786848, &quot;трифонов&quot;)</code></pre>
<p>Некоторые полезные атрибуты объектов <code>IntervalTier</code> и
<code>PointTier</code>:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(word_tier.name)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(word_tier.start_time)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(word_tier.end_time)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(word_tier.tier_type())</span></code></pre></div>
<pre><code>words
0.0
1.747619047619047
IntervalTier</code></pre>
<p>Ознакомьтесь со списком методов уровней в <a
href="https://textgridtools.readthedocs.io/en/stable/api.html#tgt.core.Tier">документации</a>.
Обратите внимание на методы для удаления и получения элементов аннотации
по времени, тексту и т. п.</p>
<p>Атрибуты объектов <code>Interval</code>:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>one_word <span class="op">=</span> word_tier[<span class="dv">0</span>]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(one_word.start_time)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(one_word.end_time)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(one_word.text)</span></code></pre></div>
<pre><code>0.0
0.412244897959183
юрий</code></pre>
<p>Атрибуты объектов <code>Point</code>:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>point <span class="op">=</span> grid.get_tier_by_name(<span class="st">&quot;word boundaries&quot;</span>)[<span class="dv">0</span>]</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(point.time)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(point.text)</span></code></pre></div>
<pre><code>0.412244897959183
1</code></pre>
<p>Чтобы создать пустой <code>TextGrid</code>, создадим экземпляр
класса:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> tgt.TextGrid()</span></code></pre></div>
<p>Добавим в него новый <code>IntervalTier</code> с помощью метода
<code>.add_tier()</code>:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>new_tier <span class="op">=</span> tgt.IntervalTier(name<span class="op">=</span><span class="st">&quot;new tier&quot;</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>grid.add_tier(new_tier)</span></code></pre></div>
<p>Если мы хотим добавить сразу несколько уровней, можно воспользоваться
методом <code>.add_tiers()</code>. Чтобы добавить уровень не в конец
списка, а в заданную позицию, можно воспользоваться методом
<code>.insert_tier()</code>, который вторым аргументом принимает на вход
необходимую позицию в виде целого числа. Удалить уровень или уровни
можно с помощью методов <code>.delete_tier()</code> и
<code>.delete_tiers()</code> соответственно.</p>
<p>Добавим в уровень новый интервал, который начинается в 0 с,
заканчивается в 1 с и называется "some text":</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>new_tier.add_interval(tgt.Interval(<span class="dv">0</span>, <span class="fl">1.0</span>, <span class="st">&quot;some text&quot;</span>))</span></code></pre></div>
<p>Добавим новый <code>PointTier</code>:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>new_point_tier <span class="op">=</span> tgt.PointTier(name<span class="op">=</span><span class="st">&quot;new point tier&quot;</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>grid.add_tier(new_point_tier)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>new_point_tier.add_point(tgt.Point(<span class="fl">0.5</span>, <span class="st">&quot;some text&quot;</span>))</span></code></pre></div>
<p>Запишем в разных форматах:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>tgt.io.write_to_file(grid, <span class="st">&quot;new_grid_short.TextGrid&quot;</span>, <span class="bu">format</span><span class="op">=</span><span class="st">&quot;short&quot;</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>tgt.io.write_to_file(grid, <span class="st">&quot;new_grid_long.TextGrid&quot;</span>, <span class="bu">format</span><span class="op">=</span><span class="st">&quot;long&quot;</span>)</span></code></pre></div>
<h3 id="практические-задания">Практические задания</h3>
<h4 id="задание-1">Задание 1</h4>
<p>Напишите цикл, который перебирает все интервалы из уровня
<code>"phonetic real"</code> и выводит на экран название каждого
интервала и его серединную точку.</p>
<h4 id="задание-2">Задание 2</h4>
<p>Напишите функцию, которая принимает на вход имя файла .seg и делает
следующее:</p>
<ol type="1">
<li>Читает из файла метки и параметры (вызывая отдельную функцию
<code>read_seg()</code>);</li>
<li>создаёт новый <code>TextGrid</code> и уровень <code>IntervalTier</code>;</li>
<li>Добавляет новый уровень в новый <code>TextGrid</code>;</li>
<li>Перебирает циклом все пары соседних меток;</li>
<li>Добавляет в уровень все интервалы, полученные таким образом
(соответственно, время начала каждого интервала — позиция левой метки в
паре, время конца — позиция правой, текст — имя левой метки);</li>
<li>Записывает получившийся объект <code>TextGrid</code> в файл
.TextGrid.</li>
</ol>
<p>Откройте полученный файл в Praat и посмотрите на него.</p>
<h4 id="задание-3">Задание 3</h4>
<p>Напишите без использования сторонних библиотек функцию, которая
получает на вход имя файла .TextGrid (на ваш выбор — короткого или
длинного), а возвращает список словарей вида:</p>
<pre><code>[
    {
        &quot;name&quot;: &quot;название уровня&quot;,
        &quot;type&quot;: &quot;interval&quot; или &quot;point&quot;,
        &quot;data&quot;:
        [
            #для interval tier
            (метка начала в миллисекундах, метка конца в миллисекундах, текст метки),
            #для point tier
            (метка в миллисекундах, текст метки),
        ]
    }
]</code></pre>
<h4 id="задание-4">Задание 4</h4>
<p>Написать программу, которая:</p>
<ol type="1">
<li>Обрабатывает все файлы .seg в архиве cta_seg;</li>
<li>Для каждого аллофона вычисляет его среднюю длительность (в секундах)
и стандартное отклонение;</li>
<li>Для файла cta0001 генерирует файл .TextGrid с двумя уровнями. Первый
должен содержать информацию из .seg_B1 (границы звуков и их названия), а
второй должен совпадать с первым, но имя каждого интервала должно
содержать не название звука, а его длительность, нормализованную путём
<a
href="https://en.wikipedia.org/wiki/Standard_score">z-нормализации</a> и
округлённую до 3 знаков после запятой.</li>
</ol>
<p>Чтобы вычислить нормализованную длительность звука, нужно из его
физической длительности (в секундах) вычесть среднее значение
длительности этого аллофона <strong>по всему корпусу</strong> и
разделить на стандартное отклонение.</p>
<p>Т.е. чтобы сделать это для, например, звука [u0] из слова "юрий",
нужно определить среднее и ст. отклонение по всем звукам [u0] из всего
корпуса и использовать эти значения. Для звука [r'] эти значения уже
будут другими.</p>
<p>В качестве иллюстрации: сгенерируем массив из 100 случайных чисел и
вычислим его среднее значение и стандартное отклонение.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code></pre></div>
<div class="sourceCode" id="cb29"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng()</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> rng.normal(loc<span class="op">=</span><span class="dv">3</span>, scale<span class="op">=</span><span class="fl">1.5</span>, size<span class="op">=</span><span class="dv">100</span>)  <span class="co"># нормальное распределение с МО=3 и СКО=1.5</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>mean_value <span class="op">=</span> np.mean(nums)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>st_dev <span class="op">=</span> np.std(nums)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mean_value, st_dev)</span></code></pre></div>
<p>Сгенерируем ещё одно случайное число из того же распределения и
нормализуем его:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>new_num <span class="op">=</span> rng.normal(loc<span class="op">=</span><span class="dv">3</span>, scale<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>norm_num <span class="op">=</span> (new_num <span class="op">-</span> mean_value) <span class="op">/</span> st_dev</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(new_num, norm_num)</span></code></pre></div>
<p>Не забудьте открыть полученный файл в Praat, чтобы убедиться в том,
что он:</p>
<ol type="1">
<li>Открывается</li>
<li>Содержит нужные данные</li>
<li>Полученные значения адекватны — получиться должно примерно следующее
(точные значения могут отличаться):</li>
</ol>
<img src="courses/python_textbook/images/result_example.png" width="80%">

<h4 id="задание-5">Задание 5</h4>
<p>В системе просодической разметки ToBI есть два уровня аннотации:
уровень тонов (<em>tones</em>) и уровень границ (<em>breaks</em>).
Границы классифицируются по силе от 0 до 4, где 3 — граница
промежуточной интонационной фразы (<em>intermediate phrase, ip</em>), 4
— граница полной интонационной фразы (<em>intonational phrase, IP</em>).
Тоны делятся на тональные акценты (*), фразовые акценты (-) и граничные
тоны (%). Тональные акценты ассоциируются с ударными слогами, фразовые
акценты — с границей <em>ip</em>, а граничные тоны — с границей
<em>IP</em>.</p>
<p>В приведённом файле TextGrid (h1r1.TextGrid) дана разметка по системе
ToBI (точечные уровни). Приведите её в соответствие стандартам. Для
этого:</p>
<ol type="1">
<li>Слейте в одну точку фразовый акцент и следующий непосредственно за
ним граничный тон.</li>
<li>Измените положение фразовых акцентов и граничных тонов так, чтобы
они приходились точно на ближайшие границы индексов 3 и 4
соответственно.</li>
</ol>
<h3
id="дополнительный-материал-конвертация-из-триграфов-praat-в-символы-unicode">Дополнительный
материал: конвертация из триграфов Praat в символы Unicode</h3>
<p>Для хранения символов, не входящих в таблицу ASCII (символов МФА,
кириллицы и других алфавитов), Praat пользуется своей собственной
системой: каждому символу, не входящему в ASCII, сопоставляется т.н.
триграф. Под триграфом понимается последовательность из обратного слеша
\ и двух символов ASCII. Например, символу ɨ соответствует триграф
\i-.</p>
<p><a
href="https://www.fon.hum.uva.nl/praat/manual/TextGrid_file_formats.html">https://www.fon.hum.uva.nl/praat/manual/TextGrid_file_formats.html</a><br />
<a
href="https://www.fon.hum.uva.nl/praat/manual/Special_symbols.html">https://www.fon.hum.uva.nl/praat/manual/Special_symbols.html</a></p>
<p>Всего в Praat определено несколько сотен таких триграфов, набор
периодически расширяется (всего их возможно несколько тысяч, что,
конечно, гораздо меньше, чем количество символов, определённых в
Unicode).</p>
<p>Файлы .TextGrid могут содержать как один вариант записи, так и
другой. Для конвертации рекомендуется использовать саму программу Praat
(вручную, написав скрипт или через библиотеку <code>parselmouth</code>).
Однако можно заняться конвертацией самостоятельно, если очень хочется.
Для этого посмотрим на ту часть исходного кода Praat, которая отвечает
за конвертацию.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># скачаем файлы исходного кода</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>wget https:<span class="op">//</span>raw.githubusercontent.com<span class="op">/</span>praat<span class="op">/</span>praat<span class="op">/</span>master<span class="op">/</span>kar<span class="op">/</span>longchar.cpp</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>wget https:<span class="op">//</span>raw.githubusercontent.com<span class="op">/</span>praat<span class="op">/</span>praat<span class="op">/</span>master<span class="op">/</span>kar<span class="op">/</span>UnicodeData.h</span></code></pre></div>
<div class="sourceCode" id="cb32"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">&quot;UnicodeData.h&quot;</span>) <span class="im">as</span> f:</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    lines <span class="op">=</span> f.readlines()</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co"># здесь хранятся коды символов Unicode в шестнадцатеричном представлении</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>unicode_vals <span class="op">=</span> {}</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> line <span class="kw">in</span> lines:</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> line.startswith(<span class="st">&quot;#define&quot;</span>):</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    _, name, val <span class="op">=</span> line.strip().split()</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> name.startswith(<span class="st">&quot;UNICODE&quot;</span>):</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    unicode_vals[name] <span class="op">=</span> <span class="bu">chr</span>(<span class="bu">int</span>(val, <span class="dv">16</span>))</span></code></pre></div>
<div class="sourceCode" id="cb33"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">&quot;longchar.cpp&quot;</span>) <span class="im">as</span> f:</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    lines <span class="op">=</span> f.readlines()</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>trigraph2unicode <span class="op">=</span> {}</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="co"># здесь хранится таблица соответствий</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> line <span class="kw">in</span> lines:</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    line <span class="op">=</span> line.replace(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">&#39;&quot;</span>, <span class="st">&quot;&#39;&quot;</span>)</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    line <span class="op">=</span> line.replace(<span class="st">&#39;</span><span class="ch">\\</span><span class="st">&quot;&#39;</span>, <span class="st">&#39;&quot;&#39;</span>)</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># напишем регулярное выражение, которое ищет в строке таблицы символы, входящие в триграф, и название символа Unicode</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> re.search(<span class="st">&quot;(&#39;[^,]+&#39;), ?(&#39;[^,]+&#39;),.+(UNICODE_</span><span class="er">\</span><span class="st">w+)&quot;</span>, line)</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> m <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>    ch1, ch2, name <span class="op">=</span> m[<span class="dv">1</span>][<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>], m[<span class="dv">2</span>][<span class="dv">1</span>:<span class="op">-</span><span class="dv">1</span>], m[<span class="dv">3</span>]</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ch2 <span class="op">==</span> <span class="st">&quot; &quot;</span>:</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>    trigraph2unicode[<span class="st">&quot;</span><span class="ch">\\</span><span class="st">&quot;</span> <span class="op">+</span> ch1 <span class="op">+</span> ch2] <span class="op">=</span> unicode_vals[name]</span></code></pre></div>
<div class="sourceCode" id="cb34"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># сделаем словарь для обратной конвертации</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>unicode2trigraph <span class="op">=</span> {j: i <span class="cf">for</span> i, j <span class="kw">in</span> trigraph2unicode.items()}</span></code></pre></div>
<div class="sourceCode" id="cb35"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># проверим:</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>trigraph2unicode[<span class="st">&quot;</span><span class="ch">\\</span><span class="st">O</span><span class="ch">\&quot;</span><span class="st">&quot;</span>]</span></code></pre></div>
<pre><code>&#39;Ö&#39;</code></pre>
<div class="sourceCode" id="cb37"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>unicode_string <span class="op">=</span> <span class="st">&quot;bɨl tʲixʲij sʲerɨj vʲet͡ʃʲir&quot;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>trigraph_string <span class="op">=</span> unicode_string.translate(<span class="bu">str</span>.maketrans(unicode2trigraph))</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(trigraph_string)</span></code></pre></div>


</div>
</body>
</html>
