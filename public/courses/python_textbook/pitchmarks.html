<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Файловые системы и работа с многоуровневой разметкой</title>
    <style>
        .chapter-content {
            font-family: Arial, sans-serif;
            line-height: 1.6;
        }

        h2 {
            color: #2c3e50;
        }

        .note {
            background: #f8f9fa;
            padding: 10px;
            border-left: 3px solid #3498db;
        }
    </style>
    <link href="styles/syntax_highlight.css" rel="stylesheet">
    <base target="_blank">
</head>

<body>
<div class="chapter-content">
<p>Часто (но не всегда) информация о частоте основного тона (ЧОТ) в
сигнале хранится в виде меток, которые обозначают границы периодов
основного тона (ОТ). Заметьте, что принципы расставления границ могут
отличаться: у нас началом периода принято считать переход через 0 в
положительную область, в других местах — минимальное значение
(отрицательный пик) или максимальное (положительный).</p>
<h3 id="основные-форматы-записи-меток-основного-тона">Основные форматы
записи меток основного тона</h3>
<h4 id="формат-seg_g1-wave-assistant">Формат SEG_G1 (Wave
Assistant)</h4>
<p>Wave Assistant расставляет границы периодов основного тона на уровне
G1. На этом уровне часто (но не всегда!) также находятся метки,
обозначающие границы файла. Они не являются метками границ периодов
ОТ.</p>
<h4 id="формат-pointprocess-praat">Формат PointProcess (Praat)</h4>
<p>Praat также позволяет получить информацию о границах периодов
основного тона. Для этого можно воспользоваться командой “Sound: To
PointProcess (periodic, cc)...”. Границы периодов ставятся по
положительным пикам. Получившийся объект называется PointProcess и может
быть сохранён в текстовом файле. Его типичная структура такова:</p>
<pre><code>File type = &quot;ooTextFile&quot;
Object class = &quot;PointProcess&quot;

xmin = 0 
xmax = 1.7476190476190476 
nt = 197 
t []: 
    t [1] = 0.024561283415243513 
    t [2] = 0.031026605393017187 
    t [3] = 0.037651095764738 
    t [4] = 0.04419282874185799 
    t [5] = 0.05071072241657426</code></pre>
<p>Время каждой метки хранится в виде вещественного числа и выражено в
секундах. Кроме меток, файл содержит также информацию о времени начала и
конца файла (также в секундах) и количестве меток.</p>
<h4 id="формат-pm-reaper">Формат PM (REAPER)</h4>
<p>Утилита <a href="https://github.com/google/REAPER">REAPER</a>,
позволяющая с довольно высокой точностью получать границы периодов
основного тона, также даёт информацию о границах периодов. Здесь они
ставятся по отрицательным пикам.</p>
<p>Если вы работаете в Unix-подобной системе, REAPER можно легко
установить с GitHub. Для этого запустим следующий код. Если вы делаете
это в Google Colab, первой строчкой ячейки должна быть %%bash, чтобы
показать, что это консольные команды. Если вы работаете на локальной
машине, просто вводите все строчки, начиная со второй, в терминал (перед
этим перейдите в удобную директорию).</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">%%bash</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> clone https://github.com/google/REAPER.git</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> REAPER</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">mkdir</span> build   <span class="co"># In the REAPER top-level directory</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> build</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="fu">cmake</span> ..</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="fu">make</span></span></code></pre></div>
<p>Чтобы запустить REAPER в Google Colab, запустите такую ячейку:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">%%bash</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ex">REAPER/build/reaper</span> <span class="at">-i</span> cta0001.wav <span class="at">-p</span> cta0001.pm <span class="at">-a</span></span></code></pre></div>
<p>Для запуска на локальной машине введите в консоль такую команду:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">%%bash</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ex">REAPER/build/reaper</span> <span class="at">-i</span> cta0001.wav <span class="at">-p</span> cta0001.pm <span class="at">-a</span></span></code></pre></div>
<p>Параметр <code>-i</code> указывает на имя входного файла,
<code>-p</code> — на имя выходного файла с метками, <code>-a</code> —
указывает программе писать результат в виде текстового файла.</p>
<p>Структура файла такова:</p>
<pre><code>EST_File Track
DataType ascii
NumFrames 271
NumChannels 1
FrameShift 0.00000
VoicingEnabled true
EST_Header_End
0.004580 1 0.000000
0.011293 1 0.000000
0.017687 1 0.000000
0.024263 1 0.000000
0.030884 1 0.000000
0.037415 1 0.000000</code></pre>
<p>В поле <code>NumFrames</code> содержится количество меток, после
конца заголовка <code>EST_Header_End</code> начинаются собственно
данные, где первое поле — время метки в секундах, второе поле содержит
1, если фрейм звонкий, и 0, если он глухой. Третье поле содержит частоту
основного тона, которая в этом режиме не вычисляется.</p>
<p>С параметром <code>-f</code> REAPER сгенерирует аналогичный файл, но
содержащий не границы периодов, а значения частоты основного тона с
равным шагом (для таких файлов предлагается использовать расширение
.f0).</p>
<pre><code>EST_File Track
DataType ascii
NumFrames 345
NumChannels 1
FrameShift 0.00000
VoicingEnabled true
EST_Header_End
0.000000 0 -1.000000
0.005000 1 143.181824
0.010000 1 156.382980
0.015000 1 156.382980
0.020000 1 169.615387
0.025000 1 155.281693</code></pre>
<p>На глухих участках значение ЧОТ всегда будет равно −1.0.</p>
<h3 id="обработка-меток-периодов">Обработка меток периодов</h3>
<p>Вспомним, что часто для извлечения информации из меток необходимо
обрабатывать их парами. Метки границ периодов ОТ — не исключение. Если
мы знаем положение двух соседних меток, мы легко можем вычислить длину
соответствующего периода как разность из позиций, а из длины периода —
значение ЧОТ как обратную ей величину.</p>
<p>Не любая пара меток в файле соответствует периоду ОТ. Некоторые из
них отмечают глухие участки:</p>
<img src="courses/python_textbook/images/voiceless_part.png" width="80%">

<p>Отличить одно от другого мы можем, задав минимальное возможное
значение ЧОТ. Тогда мы сможем отличить такие интервалы по длине:
периодами ОТ будут только те интервалы, которые короче определённого
порога. Таким парам меток удобно сопоставить значение NaN. NaN (Not a
Number) — значение, которое часто используют в качестве заместителя для
пропущенных данных. Его можно получить, например, так:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>nan_val <span class="op">=</span> <span class="bu">float</span>(<span class="st">&quot;nan&quot;</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(nan_val)</span></code></pre></div>
<p>Или так:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>nan_val2 <span class="op">=</span> np.nan</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(nan_val2)</span></code></pre></div>
<p>NaN не равен никакому числу и не равен сам себе:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>nan_val <span class="op">==</span> nan_val</span></code></pre></div>
<p>Чтобы проверить, является ли значение NaN, есть специальные
функции:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>np.isnan(nan_val)</span></code></pre></div>
<p>Если мы будем строить графики по данным, содержащим NaN, с помощью
matplotlib, то в соответствующих местах появятся разрывы. Сравните:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">10</span>))</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>y1 <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, np.nan, np.nan, <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>y2 <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>]</span></code></pre></div>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].plot(x, y1)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].plot(x, y2)</span></code></pre></div>
<img src="courses/python_textbook/images/nan_plot.png" width="40%">

<h3 id="практические-задания">Практические задания</h3>
<h4 id="1-построение-графика-чот-из-файла-seg_g1">1. Построение графика
ЧОТ из файла SEG_G1</h4>
<p>Напишите функцию, которая принимает на вход имя файла SEG и
минимальное значение ЧОТ, а возвращает пару из двух списков: список
позиций каждого периода (за позицию периода возьмите его середину) и
список значений ЧОТ в каждом периоде. Глухим участкам сопоставьте
значение NaN.</p>
<p>Алгоритм выполнения:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_f0(filename: <span class="bu">str</span>, min_f0: <span class="bu">float</span> <span class="op">=</span> <span class="fl">50.0</span>) <span class="op">-&gt;</span> <span class="bu">tuple</span>[<span class="bu">list</span>[<span class="bu">float</span>], <span class="bu">list</span>[<span class="bu">float</span>]]:</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    times, f0_values <span class="op">=</span> [], []</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># прочитать сег</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># убрать из него метки начала и конца файла</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># перебрать метки попарно</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># в каждом интервале:</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># определить место середины В СЕКУНДАХ, добавить в times</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># определить значение ЧОТ</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># если оно &gt;= минимального, добавить в f0_values</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># в противном случае добавить в f0_values NaN</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> times, f0_values</span></code></pre></div>
<p>Используйте эту функцию для построения графика несглаженной ЧОТ:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>times, f0_values <span class="op">=</span> get_f0(<span class="st">&quot;cta0001.seg_G1&quot;</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>plt.plot(times, f0_values)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
<h4 id="2-определение-границ-звонких-участков">2. Определение границ
звонких участков</h4>
<p>Напишите программу, которая определяет границы каждого звонкого
участка в файле по меткам ОТ и записывает их в файл SEG_G2. Названием
каждого метки сделайте число, которое показывает разницу между
максимальным и минимальным значением ЧОТ в этом участке. Выразите эту
разницу в полутонах. Формула для перевода разницы между двумя частотами
в полутона:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mo>=</mo><mn>12</mn><mo>⋅</mo><msub><mrow><mi mathvariant="normal">log</mi><mo>&#8289;</mo></mrow><mn>2</mn></msub><mfrac><msub><mi>f</mi><mn>2</mn></msub><msub><mi>f</mi><mn>1</mn></msub></mfrac></mrow><annotation encoding="application/x-tex"> st = 12 \cdot \log_{2}{\frac{f_2}{f_1}} </annotation></semantics></math></p>
<p>Функции для логарифма:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> log2</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>log2(<span class="dv">10</span>)</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>np.log2(<span class="dv">10</span>)</span></code></pre></div>
<p>Возможный алгоритм:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> voiced_regions(seg_filename: <span class="bu">str</span>, min_f0: <span class="bu">float</span> <span class="op">=</span> <span class="dv">50</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># прочитаем метки из файла</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># создадим список, куда будем добавлять наши звонкие участки</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># каждый звонкий участок характеризуется тремя параметрами:</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># время начала, время конца, список значений ЧОТ внутри него</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># можно реализовать это в виде словаря с тремя ключами,</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># два из которых будут хранить числовые значения, третий - список чисел</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># сразу добавим в этот список первый участок</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># его время начала соотвествует первой метке</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># а время конца мы ещё не знаем</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># переберём все пары меток</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># если пара является настоящим периодом ОТ, то добавляем значение ЧОТ в текущий участок</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (т.е. последний участок в большом списке)</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># иначе текущему участку назначаем время конца, равное левой метке в паре</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># и добавляем в большой список новый участок со временем начала, равным правой метке в паре</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># после конца цикла последнему участку назначим время конца, равное последней метке</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># заведём список новых меток</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># переберём все участки</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># для каждого вычислим перепад ЧОТ, переведём в строку</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># создадим метку начала на уровне G2 с таким названием и метку конца с пустым названием </span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># запишем все созданные метки в файл с необходимыми параметрами</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span></code></pre></div>

</div>
</body>
</html>
